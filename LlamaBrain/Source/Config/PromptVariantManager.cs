#nullable enable
using System;
using System.Collections.Generic;
using System.Linq;

namespace LlamaBrain.Config
{
  /// <summary>
  /// Represents a prompt variant for A/B testing.
  /// </summary>
  public class PromptVariant
  {
    /// <summary>
    /// The name of the variant (e.g., "Control", "Experimental").
    /// </summary>
    public string Name { get; set; } = "";

    /// <summary>
    /// The system prompt for this variant.
    /// </summary>
    public string SystemPrompt { get; set; } = "";

    /// <summary>
    /// The percentage of traffic this variant should receive (0.0-100.0).
    /// </summary>
    public float TrafficPercentage { get; set; }

    /// <summary>
    /// Whether this variant is currently active.
    /// Inactive variants are skipped during selection.
    /// </summary>
    public bool IsActive { get; set; } = true;
  }

  /// <summary>
  /// Tracks metrics for a specific variant.
  /// </summary>
  public class VariantMetrics
  {
    /// <summary>
    /// Number of times this variant was selected.
    /// </summary>
    public int SelectionCount { get; set; }

    /// <summary>
    /// Number of successful interactions with this variant.
    /// </summary>
    public int SuccessCount { get; set; }

    /// <summary>
    /// Number of validation failures with this variant.
    /// </summary>
    public int ValidationFailureCount { get; set; }

    /// <summary>
    /// Number of times this variant fell back to default.
    /// </summary>
    public int FallbackCount { get; set; }

    /// <summary>
    /// Average latency in milliseconds for this variant.
    /// </summary>
    public double AvgLatencyMs { get; set; }

    /// <summary>
    /// Average number of tokens generated by this variant.
    /// </summary>
    public double AvgTokensGenerated { get; set; }
  }

  /// <summary>
  /// Manages A/B testing of prompt variants with deterministic selection.
  /// Uses InteractionCount-based hashing for stable variant assignment.
  /// </summary>
  public class PromptVariantManager
  {
    private readonly List<PromptVariant> _variants;
    private readonly Dictionary<string, VariantMetrics> _metrics;
    private readonly object _metricsLock = new object();

    /// <summary>
    /// Creates a new PromptVariantManager with the specified variants.
    /// </summary>
    /// <param name="variants">List of prompt variants for A/B testing</param>
    /// <exception cref="ArgumentException">Thrown if variants list is empty</exception>
    public PromptVariantManager(List<PromptVariant> variants)
    {
      if (variants == null || variants.Count == 0)
      {
        throw new ArgumentException("Variants list cannot be null or empty", nameof(variants));
      }

      _variants = variants;
      _metrics = new Dictionary<string, VariantMetrics>();

      // Initialize metrics for each variant
      foreach (var variant in _variants)
      {
        _metrics[variant.Name] = new VariantMetrics();
      }
    }

    /// <summary>
    /// Selects a variant deterministically based on seed (InteractionCount) and personaId.
    /// Uses consistent hashing to ensure the same seed+personaId always selects the same variant.
    /// Thread-safe.
    /// </summary>
    /// <param name="seed">The seed (typically InteractionCount) for deterministic selection</param>
    /// <param name="personaId">The persona ID to mix into the hash</param>
    /// <returns>The selected PromptVariant</returns>
    public PromptVariant SelectVariant(int seed, string personaId)
    {
      // Deterministic hash based on seed (InteractionCount) + personaId
      var hash = HashCode.Combine(seed, personaId);
      var bucket = Math.Abs(hash % 100); // 0-99 bucket

      // Get active variants sorted by name (stable ordering for determinism)
      var activeVariants = _variants
        .Where(v => v.IsActive)
        .OrderBy(v => v.Name)
        .ToList();

      // If no active variants, return first variant as fallback
      if (activeVariants.Count == 0)
      {
        return _variants[0];
      }

      // Select variant based on cumulative traffic percentage
      float cumulative = 0f;
      foreach (var variant in activeVariants)
      {
        cumulative += variant.TrafficPercentage;
        if (bucket < cumulative)
        {
          // Track selection (thread-safe)
          lock (_metricsLock)
          {
            _metrics[variant.Name].SelectionCount++;
          }
          return variant;
        }
      }

      // Fallback to first active variant if bucket falls outside range
      var fallbackVariant = activeVariants[0];
      lock (_metricsLock)
      {
        _metrics[fallbackVariant.Name].SelectionCount++;
      }
      return fallbackVariant;
    }

    /// <summary>
    /// Gets the current metrics for all variants.
    /// </summary>
    /// <returns>Dictionary mapping variant name to metrics</returns>
    public Dictionary<string, VariantMetrics> GetMetrics()
    {
      return new Dictionary<string, VariantMetrics>(_metrics);
    }

    /// <summary>
    /// Resets all metrics to zero.
    /// </summary>
    public void ResetMetrics()
    {
      foreach (var metrics in _metrics.Values)
      {
        metrics.SelectionCount = 0;
        metrics.SuccessCount = 0;
        metrics.ValidationFailureCount = 0;
        metrics.FallbackCount = 0;
        metrics.AvgLatencyMs = 0;
        metrics.AvgTokensGenerated = 0;
      }
    }

    /// <summary>
    /// Records a successful interaction for the specified variant.
    /// Thread-safe.
    /// </summary>
    /// <param name="variantName">The name of the variant</param>
    public void RecordSuccess(string variantName)
    {
      lock (_metricsLock)
      {
        if (_metrics.ContainsKey(variantName))
        {
          _metrics[variantName].SuccessCount++;
        }
      }
    }

    /// <summary>
    /// Records a validation failure for the specified variant.
    /// Thread-safe.
    /// </summary>
    /// <param name="variantName">The name of the variant</param>
    public void RecordValidationFailure(string variantName)
    {
      lock (_metricsLock)
      {
        if (_metrics.ContainsKey(variantName))
        {
          _metrics[variantName].ValidationFailureCount++;
        }
      }
    }

    /// <summary>
    /// Records a fallback occurrence for the specified variant.
    /// Thread-safe.
    /// </summary>
    /// <param name="variantName">The name of the variant</param>
    public void RecordFallback(string variantName)
    {
      lock (_metricsLock)
      {
        if (_metrics.ContainsKey(variantName))
        {
          _metrics[variantName].FallbackCount++;
        }
      }
    }

    /// <summary>
    /// Updates the average latency for the specified variant.
    /// Uses incremental averaging to avoid storing all latency values.
    /// Thread-safe.
    /// </summary>
    /// <param name="variantName">The name of the variant</param>
    /// <param name="latencyMs">The latency in milliseconds</param>
    public void RecordLatency(string variantName, double latencyMs)
    {
      lock (_metricsLock)
      {
        if (_metrics.ContainsKey(variantName))
        {
          var metrics = _metrics[variantName];
          var count = metrics.SelectionCount;
          if (count > 0)
          {
            // Incremental average: new_avg = old_avg + (new_value - old_avg) / count
            metrics.AvgLatencyMs += (latencyMs - metrics.AvgLatencyMs) / count;
          }
        }
      }
    }

    /// <summary>
    /// Updates the average tokens generated for the specified variant.
    /// Uses incremental averaging to avoid storing all token counts.
    /// Thread-safe.
    /// </summary>
    /// <param name="variantName">The name of the variant</param>
    /// <param name="tokens">The number of tokens generated</param>
    public void RecordTokens(string variantName, double tokens)
    {
      lock (_metricsLock)
      {
        if (_metrics.ContainsKey(variantName))
        {
          var metrics = _metrics[variantName];
          var count = metrics.SelectionCount;
          if (count > 0)
          {
            // Incremental average: new_avg = old_avg + (new_value - old_avg) / count
            metrics.AvgTokensGenerated += (tokens - metrics.AvgTokensGenerated) / count;
          }
        }
      }
    }
  }
}
