using System;
using System.Collections.Generic;
using LlamaBrain.Core.Expectancy;
using LlamaBrain.Core;

namespace LlamaBrain.Core.Metrics
{
  /// <summary>
  /// Represents a single dialogue interaction with full metrics.
  /// This is a framework-agnostic data model that can be used by any host implementation.
  /// </summary>
  [System.Serializable]
  public class DialogueInteraction
  {
    /// <summary>
    /// Unique identifier for this interaction.
    /// </summary>
    public string InteractionId { get; set; } = Guid.NewGuid().ToString();
    
    /// <summary>
    /// Timestamp when this interaction occurred.
    /// </summary>
    public DateTime Timestamp { get; set; } = DateTime.Now;
    
    // Trigger Information
    /// <summary>
    /// The ID of the trigger that initiated this interaction.
    /// </summary>
    public string TriggerId { get; set; } = string.Empty;
    
    /// <summary>
    /// The name of the trigger that initiated this interaction.
    /// </summary>
    public string TriggerName { get; set; } = string.Empty;
    
    /// <summary>
    /// The prompt text used for this interaction.
    /// </summary>
    public string PromptText { get; set; } = string.Empty;
    
    /// <summary>
    /// The number of times the trigger was prompted before this interaction.
    /// </summary>
    public int PromptCount { get; set; }
    
    // NPC Information
    /// <summary>
    /// The name of the NPC involved in this interaction.
    /// </summary>
    public string NpcName { get; set; } = string.Empty;
    
    // Response Information
    /// <summary>
    /// The response text generated by the NPC.
    /// </summary>
    public string ResponseText { get; set; } = string.Empty;
    
    /// <summary>
    /// The length of the response text in characters.
    /// </summary>
    public int ResponseLength { get; set; }
    
    // Performance Metrics
    /// <summary>
    /// Time to first token in milliseconds.
    /// </summary>
    public long TtftMs { get; set; }
    
    /// <summary>
    /// Prefill time in milliseconds.
    /// </summary>
    public long PrefillTimeMs { get; set; }
    
    /// <summary>
    /// Decode time in milliseconds.
    /// </summary>
    public long DecodeTimeMs { get; set; }
    
    /// <summary>
    /// Total time for the interaction in milliseconds.
    /// </summary>
    public long TotalTimeMs { get; set; }
    
    // Token Metrics
    /// <summary>
    /// Number of tokens in the prompt.
    /// </summary>
    public int PromptTokenCount { get; set; }
    
    /// <summary>
    /// Number of tokens generated.
    /// </summary>
    public int GeneratedTokenCount { get; set; }
    
    /// <summary>
    /// Number of cached tokens used.
    /// </summary>
    public int CachedTokenCount { get; set; }
    
    /// <summary>
    /// Tokens generated per second.
    /// </summary>
    public double TokensPerSecond { get; set; }

    // KV Cache Metrics (Feature 27)
    /// <summary>
    /// Estimated tokens in the static prefix (system prompt + canonical facts).
    /// Used for calculating cache efficiency.
    /// </summary>
    public int StaticPrefixTokens { get; set; }

    /// <summary>
    /// Cache efficiency: ratio of cached tokens to static prefix tokens.
    /// A value close to 1.0 indicates optimal cache utilization.
    /// Returns 0 if no static prefix tokens were tracked.
    /// </summary>
    public double CacheEfficiency
    {
      get
      {
        if (StaticPrefixTokens == 0) return 0.0;
        return (double)CachedTokenCount / StaticPrefixTokens;
      }
    }

    /// <summary>
    /// Whether KV caching was enabled for this interaction.
    /// </summary>
    public bool KvCachingEnabled { get; set; }

    // Quality Flags
    /// <summary>
    /// Whether the response was truncated.
    /// </summary>
    public bool WasTruncated { get; set; }
    
    // Validation Metrics (Phase 5)
    /// <summary>
    /// Whether validation passed (true) or failed (false).
    /// </summary>
    public bool ValidationPassed { get; set; }
    
    /// <summary>
    /// Number of validation failures (0 if validation passed).
    /// </summary>
    public int ValidationFailureCount { get; set; }
    
    /// <summary>
    /// Types of constraint violations (comma-separated list).
    /// </summary>
    public string ConstraintViolationTypes { get; set; } = string.Empty;
    
    /// <summary>
    /// Whether a critical validation failure occurred.
    /// </summary>
    public bool HasCriticalFailure { get; set; }
    
    // Retry Metrics (Phase 3)
    /// <summary>
    /// Number of retry attempts made (0 = first attempt succeeded).
    /// </summary>
    public int RetryCount { get; set; }
    
    /// <summary>
    /// Total number of attempts (including first attempt).
    /// </summary>
    public int TotalAttempts { get; set; }
    
    // Fallback Metrics (Phase 7)
    /// <summary>
    /// Whether a fallback response was used (true if all retries failed).
    /// </summary>
    public bool FallbackUsed { get; set; }
    
    /// <summary>
    /// The trigger reason that caused fallback (if fallback was used).
    /// </summary>
    public string FallbackTriggerReason { get; set; } = string.Empty;
    
    // Determinism Layer Metrics (Phase 1)
    /// <summary>
    /// Number of constraints applied from expectancy engine.
    /// </summary>
    public int ConstraintCount { get; set; }
    
    /// <summary>
    /// Number of prohibition constraints.
    /// </summary>
    public int ProhibitionCount { get; set; }
    
    /// <summary>
    /// Number of requirement constraints.
    /// </summary>
    public int RequirementCount { get; set; }
    
    /// <summary>
    /// Number of permission constraints.
    /// </summary>
    public int PermissionCount { get; set; }
    
    /// <summary>
    /// Creates a DialogueInteraction from CompletionMetrics and trigger info.
    /// </summary>
    /// <param name="metrics">The completion metrics from the LLM response</param>
    /// <param name="trigger">The trigger that initiated this interaction</param>
    /// <param name="npcName">The name of the NPC</param>
    /// <returns>A new DialogueInteraction with metrics populated</returns>
    public static DialogueInteraction FromMetrics(
      CompletionMetrics metrics,
      ITriggerInfo trigger,
      string npcName)
    {
      return new DialogueInteraction
      {
        Timestamp = DateTime.Now,
        TriggerId = trigger.Id.ToString(),
        TriggerName = trigger.Name,
        PromptText = trigger.PromptText,
        PromptCount = trigger.PromptCount,
        NpcName = npcName,
        ResponseText = metrics.Content ?? string.Empty,
        ResponseLength = metrics.Content?.Length ?? 0,
        TtftMs = metrics.TtftMs,
        PrefillTimeMs = metrics.PrefillTimeMs,
        DecodeTimeMs = metrics.DecodeTimeMs,
        TotalTimeMs = metrics.TotalTimeMs,
        PromptTokenCount = metrics.PromptTokenCount,
        GeneratedTokenCount = metrics.GeneratedTokenCount,
        CachedTokenCount = metrics.CachedTokenCount,
        TokensPerSecond = metrics.TokensPerSecond,
        WasTruncated = false // Will be set by caller if needed
      };
    }

    /// <summary>
    /// Populates architectural metrics from agent state.
    /// This method should be called after inference completes to capture validation, retry, and fallback data.
    /// </summary>
    /// <param name="agentMetrics">The agent metrics interface that provides inference state</param>
    public void PopulateArchitecturalMetrics(IAgentMetrics agentMetrics)
    {
      if (agentMetrics == null) return;

      // Retry metrics from InferenceResultWithRetries
      if (agentMetrics.LastInferenceResult != null)
      {
        var result = agentMetrics.LastInferenceResult;
        TotalAttempts = result.AttemptCount;
        RetryCount = Math.Max(0, result.AttemptCount - 1); // Retries = attempts - 1
        
        // Validation metrics from final result
        if (!result.Success && result.FinalResult.Violations.Count > 0)
        {
          ValidationPassed = false;
          ValidationFailureCount = result.FinalResult.Violations.Count;
          
          // Collect constraint violation types
          var violationTypes = new HashSet<string>();
          foreach (var violation in result.FinalResult.Violations)
          {
            violationTypes.Add(violation.Constraint.Type.ToString());
          }
          ConstraintViolationTypes = string.Join(",", violationTypes);
        }
        else
        {
          ValidationPassed = result.Success;
          ValidationFailureCount = 0;
        }
      }

      // Validation gate metrics
      if (agentMetrics.LastGateResult != null)
      {
        var gateResult = agentMetrics.LastGateResult;
        if (!gateResult.Passed)
        {
          ValidationPassed = false;
          ValidationFailureCount = gateResult.Failures.Count;
          HasCriticalFailure = gateResult.HasCriticalFailure;
          
          // Collect failure reasons/types
          var failureReasons = new HashSet<string>();
          foreach (var failure in gateResult.Failures)
          {
            failureReasons.Add(failure.Reason.ToString());
          }
          if (ConstraintViolationTypes == string.Empty)
          {
            ConstraintViolationTypes = string.Join(",", failureReasons);
          }
        }
        else
        {
          ValidationPassed = true;
        }
      }

      // Fallback metrics
      // Note: FallbackStats is object? to avoid coupling to Runtime types
      // Host implementations can check for fallback usage through other means
      if (!ValidationPassed && TotalAttempts > 0 && RetryCount >= 2) // Assuming max 2 retries
      {
        FallbackUsed = true;
        // Try to get trigger reason from snapshot if available
        if (agentMetrics.LastSnapshot != null && agentMetrics.LastSnapshot.Context != null)
        {
          FallbackTriggerReason = agentMetrics.LastSnapshot.Context.TriggerReason.ToString();
        }
      }

      // Determinism layer metrics (constraints)
      if (agentMetrics.LastConstraints != null)
      {
        var constraints = agentMetrics.LastConstraints;
        ConstraintCount = constraints.Count;
        
        // Count by type
        foreach (var constraint in constraints.All)
        {
          switch (constraint.Type)
          {
            case ConstraintType.Prohibition:
              ProhibitionCount++;
              break;
            case ConstraintType.Requirement:
              RequirementCount++;
              break;
            case ConstraintType.Permission:
              PermissionCount++;
              break;
          }
        }
      }
    }
  }
  
  /// <summary>
  /// Collection of all dialogue interactions for export and analysis.
  /// </summary>
  [System.Serializable]
  public class DialogueMetricsCollection
  {
    /// <summary>
    /// Unique identifier for this session.
    /// </summary>
    public string SessionId { get; set; } = Guid.NewGuid().ToString();
    
    /// <summary>
    /// When the session started.
    /// </summary>
    public DateTime SessionStart { get; set; } = DateTime.Now;
    
    /// <summary>
    /// When the session ended (null if still active).
    /// </summary>
    public DateTime? SessionEnd { get; set; }
    
    /// <summary>
    /// List of all interactions in this session.
    /// </summary>
    public List<DialogueInteraction> Interactions { get; set; } = new List<DialogueInteraction>();
    
    /// <summary>
    /// Gets the total number of interactions in this session.
    /// </summary>
    public int TotalInteractions => Interactions.Count;
    
    /// <summary>
    /// Adds an interaction to this collection.
    /// </summary>
    /// <param name="interaction">The interaction to add</param>
    public void AddInteraction(DialogueInteraction interaction)
    {
      Interactions.Add(interaction);
    }
    
    /// <summary>
    /// Marks the session as ended by setting the SessionEnd timestamp.
    /// </summary>
    public void EndSession()
    {
      SessionEnd = DateTime.Now;
    }
  }
}

